<!-- VIEW -->
=header "View"
%p
	Views hold the business logic for your application. They are bound to your view templates. Views can also be embedded in other views.

#View-defining
	=subheader "defining", "class @MyView extends @View"
	:markdown
		To create a new **View** subclass, extend the View class using standard coffescript. You should define `init` and `load` method. The `init` method is used to define any bindable variables for the view. The `load` method is called whenever the view is displayed, and should be used to update the variables defined in `init`. This usually involves loading data from the server.

		**It is important that anything bound to view templates (in a data-bind tag) be defined in `init` only, and preferably defined as an observable**. Otherwise weird things tend to happen.

		The `load` function can also be used to handle routing. This is especially important for embedded views. The format for this is identical to how `handlePath` in **Application** works.

	:coderay
		#!ruby
		class @TodoListView extends @View
			init : ->
				@todos = new TodoItem.Collection()
			load : =>
				@todos.load ['my_todos']

	:markdown
		Every **View** instance has access to a few variables that help it do its job:

		`@app` - the **Application** context  
		`@owner` - the view that owns the current view  
		`@name` - the name of the current view  

#View-init
	=subheader "init", "init : =>"
	:markdown
		Initializes view by setting up observables.
		**It is important that anything bound to view templates (in a data-bind tag) be defined in `init` only, and preferably defined as an observable**. Otherwise weird things tend to happen.

	:coderay
		#!ruby
		class @TodoListView extends @View
			init : ->
				@todos = new TodoItem.Collection()

#View-load
	=subheader "load", "load : =>"
	:markdown
		Refreshes view by loading data from server, etc. Called when the view is made visible using `selectView`, and can also be called manually.

	:coderay
		#!ruby
		class @TodoListView extends @View
			... 

			load : =>
				@todos.load ['my_todos']

#View-addView
	=subheader "addView", "@addView(name, view_class, template_name)"
	:markdown
		This method adds a view to your application.

		`name` - the name of the view. This is used with `selectView`  
		`view_class` - the View-extending class that you want to render  
		`template_name` - the name of the view template that should be bound to the view

	:coderay
		#!ruby
		class @HomeView extends @View
			...

		class @AppView extends @Application
			init : =>
				@addView('home', HomeView, 'view-home')

#View-selectView
	=subheader "selectView", "@selectView(name, [*args])"
	:markdown
		This method selects an embedded view to be displayed and hides all other embedded views. It is typically called in the routing code of your application, as the view to be rendered usually corresponds with the url path. When called, it also calls the `load` method on view to be displayed, passing the additional arguments along.

		`name` - the name of the view to display  
		`args` - arguments to pass to the `load` method of the view
	
	:coderay
		#!ruby
		@selectView('item-view', @item)
		# selects the 'todo-item' view, passing @item to the load function
